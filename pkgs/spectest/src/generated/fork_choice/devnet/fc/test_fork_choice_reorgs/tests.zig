// This file is generated by pkgs/spectest/src/generate.zig.
// Do not edit manually.

const std = @import("std");
const forks = @import("../../../../../fork.zig");
const state_transition = @import("../../../../../state_transition_runner.zig");
const fork_choice = @import("../../../../../fork_choice_runner.zig");

const test_allocator = std.testing.allocator;
const fixture_root_candidate = "leanSpec/fixtures";

const ResolveError = error{
    FixturesNotFound,
};

fn resolveFixturesRoot(allocator: std.mem.Allocator) ResolveError![]u8 {
    const cwd = std.fs.cwd();
    const resolved = cwd.realpathAlloc(allocator, fixture_root_candidate) catch {
        std.debug.print(
            "spectest: unable to locate leanSpec fixtures at {s}\n",
            .{fixture_root_candidate},
        );
        return ResolveError.FixturesNotFound;
    };
    return resolved;
}

var skip_cli_initialized = false;

fn configureSkipBehaviour() void {
    state_transition.configureSkipExpectedErrorFixturesFromEnv();
    if (skip_cli_initialized) return;
    if (parseSkipOverrideFromArgs()) |override| {
        state_transition.setSkipExpectedErrorFixtures(override);
    }
    skip_cli_initialized = true;
}

fn parseSkipOverrideFromArgs() ?bool {
    const allocator = std.heap.page_allocator;
    const argv = std.process.argsAlloc(allocator) catch return null;
    defer std.process.argsFree(allocator, argv);
    var override: ?bool = null;
    for (argv) |arg_z| {
        const arg = std.mem.sliceTo(arg_z, 0);
        if (std.mem.eql(u8, arg, "--skip-expected-error-fixtures")) {
            override = true;
        } else if (std.mem.eql(u8, arg, "--no-skip-expected-error-fixtures")) {
            override = false;
        } else if (std.mem.startsWith(u8, arg, "--skip-expected-error-fixtures=")) {
            const value = arg["--skip-expected-error-fixtures=".len..];
            override = parseBool(value);
        }
    }
    return override;
}

fn parseBool(raw: []const u8) bool {
    const trimmed = std.mem.trim(u8, raw, " \t\r\n");
    if (trimmed.len == 0) return true;
    if (equalsIgnoreCase(trimmed, "0") or equalsIgnoreCase(trimmed, "false") or equalsIgnoreCase(trimmed, "no") or equalsIgnoreCase(trimmed, "off")) return false;
    if (equalsIgnoreCase(trimmed, "1") or equalsIgnoreCase(trimmed, "true") or equalsIgnoreCase(trimmed, "yes") or equalsIgnoreCase(trimmed, "on")) return true;
    return true;
}

fn equalsIgnoreCase(lhs: []const u8, rhs: []const u8) bool {
    if (lhs.len != rhs.len) return false;
    for (lhs, rhs) |a, b| {
        if (std.ascii.toLower(a) != std.ascii.toLower(b)) return false;
    }
    return true;
}

pub const fixture_count: usize = 8;

test "devnet fc test_fork_choice_reorgs test_back_and_forth_reorg_oscillation" {
    configureSkipBehaviour();
    const fixtures_path = resolveFixturesRoot(test_allocator) catch |err| switch (err) {
        ResolveError.FixturesNotFound => return error.SkipZigTest,
        else => return err,
    };
    defer test_allocator.free(fixtures_path);
    var fixtures_dir = std.fs.openDirAbsolute(fixtures_path, .{}) catch |err| {
        std.debug.print(
            "spectest: failed to open fixtures root {s}: {s}\n",
            .{ fixtures_path, @errorName(err) },
        );
        return err;
    };
    defer fixtures_dir.close();
    const Case = fork_choice.TestCase(forks.devnet, "consensus/fork_choice/devnet/fc/test_fork_choice_reorgs/test_back_and_forth_reorg_oscillation.json");
    try Case.execute(test_allocator, fixtures_dir);
}

test "devnet fc test_fork_choice_reorgs test_reorg_on_newly_justified_slot" {
    configureSkipBehaviour();
    const fixtures_path = resolveFixturesRoot(test_allocator) catch |err| switch (err) {
        ResolveError.FixturesNotFound => return error.SkipZigTest,
        else => return err,
    };
    defer test_allocator.free(fixtures_path);
    var fixtures_dir = std.fs.openDirAbsolute(fixtures_path, .{}) catch |err| {
        std.debug.print(
            "spectest: failed to open fixtures root {s}: {s}\n",
            .{ fixtures_path, @errorName(err) },
        );
        return err;
    };
    defer fixtures_dir.close();
    const Case = fork_choice.TestCase(forks.devnet, "consensus/fork_choice/devnet/fc/test_fork_choice_reorgs/test_reorg_on_newly_justified_slot.json");
    try Case.execute(test_allocator, fixtures_dir);
}

test "devnet fc test_fork_choice_reorgs test_reorg_prevention_heavy_fork_resists_light_competition" {
    configureSkipBehaviour();
    const fixtures_path = resolveFixturesRoot(test_allocator) catch |err| switch (err) {
        ResolveError.FixturesNotFound => return error.SkipZigTest,
        else => return err,
    };
    defer test_allocator.free(fixtures_path);
    var fixtures_dir = std.fs.openDirAbsolute(fixtures_path, .{}) catch |err| {
        std.debug.print(
            "spectest: failed to open fixtures root {s}: {s}\n",
            .{ fixtures_path, @errorName(err) },
        );
        return err;
    };
    defer fixtures_dir.close();
    const Case = fork_choice.TestCase(forks.devnet, "consensus/fork_choice/devnet/fc/test_fork_choice_reorgs/test_reorg_prevention_heavy_fork_resists_light_competition.json");
    try Case.execute(test_allocator, fixtures_dir);
}

test "devnet fc test_fork_choice_reorgs test_reorg_with_slot_gaps" {
    configureSkipBehaviour();
    const fixtures_path = resolveFixturesRoot(test_allocator) catch |err| switch (err) {
        ResolveError.FixturesNotFound => return error.SkipZigTest,
        else => return err,
    };
    defer test_allocator.free(fixtures_path);
    var fixtures_dir = std.fs.openDirAbsolute(fixtures_path, .{}) catch |err| {
        std.debug.print(
            "spectest: failed to open fixtures root {s}: {s}\n",
            .{ fixtures_path, @errorName(err) },
        );
        return err;
    };
    defer fixtures_dir.close();
    const Case = fork_choice.TestCase(forks.devnet, "consensus/fork_choice/devnet/fc/test_fork_choice_reorgs/test_reorg_with_slot_gaps.json");
    try Case.execute(test_allocator, fixtures_dir);
}

test "devnet fc test_fork_choice_reorgs test_simple_one_block_reorg" {
    configureSkipBehaviour();
    const fixtures_path = resolveFixturesRoot(test_allocator) catch |err| switch (err) {
        ResolveError.FixturesNotFound => return error.SkipZigTest,
        else => return err,
    };
    defer test_allocator.free(fixtures_path);
    var fixtures_dir = std.fs.openDirAbsolute(fixtures_path, .{}) catch |err| {
        std.debug.print(
            "spectest: failed to open fixtures root {s}: {s}\n",
            .{ fixtures_path, @errorName(err) },
        );
        return err;
    };
    defer fixtures_dir.close();
    const Case = fork_choice.TestCase(forks.devnet, "consensus/fork_choice/devnet/fc/test_fork_choice_reorgs/test_simple_one_block_reorg.json");
    try Case.execute(test_allocator, fixtures_dir);
}

test "devnet fc test_fork_choice_reorgs test_three_block_deep_reorg" {
    configureSkipBehaviour();
    const fixtures_path = resolveFixturesRoot(test_allocator) catch |err| switch (err) {
        ResolveError.FixturesNotFound => return error.SkipZigTest,
        else => return err,
    };
    defer test_allocator.free(fixtures_path);
    var fixtures_dir = std.fs.openDirAbsolute(fixtures_path, .{}) catch |err| {
        std.debug.print(
            "spectest: failed to open fixtures root {s}: {s}\n",
            .{ fixtures_path, @errorName(err) },
        );
        return err;
    };
    defer fixtures_dir.close();
    const Case = fork_choice.TestCase(forks.devnet, "consensus/fork_choice/devnet/fc/test_fork_choice_reorgs/test_three_block_deep_reorg.json");
    try Case.execute(test_allocator, fixtures_dir);
}

test "devnet fc test_fork_choice_reorgs test_three_way_fork_competition" {
    configureSkipBehaviour();
    const fixtures_path = resolveFixturesRoot(test_allocator) catch |err| switch (err) {
        ResolveError.FixturesNotFound => return error.SkipZigTest,
        else => return err,
    };
    defer test_allocator.free(fixtures_path);
    var fixtures_dir = std.fs.openDirAbsolute(fixtures_path, .{}) catch |err| {
        std.debug.print(
            "spectest: failed to open fixtures root {s}: {s}\n",
            .{ fixtures_path, @errorName(err) },
        );
        return err;
    };
    defer fixtures_dir.close();
    const Case = fork_choice.TestCase(forks.devnet, "consensus/fork_choice/devnet/fc/test_fork_choice_reorgs/test_three_way_fork_competition.json");
    try Case.execute(test_allocator, fixtures_dir);
}

test "devnet fc test_fork_choice_reorgs test_two_block_reorg_progressive_building" {
    configureSkipBehaviour();
    const fixtures_path = resolveFixturesRoot(test_allocator) catch |err| switch (err) {
        ResolveError.FixturesNotFound => return error.SkipZigTest,
        else => return err,
    };
    defer test_allocator.free(fixtures_path);
    var fixtures_dir = std.fs.openDirAbsolute(fixtures_path, .{}) catch |err| {
        std.debug.print(
            "spectest: failed to open fixtures root {s}: {s}\n",
            .{ fixtures_path, @errorName(err) },
        );
        return err;
    };
    defer fixtures_dir.close();
    const Case = fork_choice.TestCase(forks.devnet, "consensus/fork_choice/devnet/fc/test_fork_choice_reorgs/test_two_block_reorg_progressive_building.json");
    try Case.execute(test_allocator, fixtures_dir);
}
